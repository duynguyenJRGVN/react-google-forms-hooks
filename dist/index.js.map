{"version":3,"file":"index.js","sources":["../src/hooks/utils/getFieldFromContext.ts","../src/hooks/useGoogleFormContext.tsx","../src/hooks/utils/useCustomOptionField.ts","../src/scripts/submitToGoogleForms.ts","../src/hooks/useGoogleForm.ts","../src/hooks/useRadioInput.ts","../src/hooks/useCheckboxInput.ts","../src/hooks/utils/useTextInput.ts","../src/hooks/useShortAnswerInput.ts","../src/hooks/useLongAnswerInput.ts","../src/hooks/utils/useGridInput.ts","../src/hooks/useCheckboxGridInput.ts","../src/hooks/useRadioGridInput.ts","../src/hooks/useDropdownInput.ts","../src/hooks/useLinearInput.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/scripts/googleFormsToJson.ts"],"sourcesContent":["import { UseGoogleFormReturn, FieldTypes } from '../../types'\r\n\r\nexport default (\r\n  context: UseGoogleFormReturn | null,\r\n  id: string,\r\n  type: FieldTypes\r\n) => {\r\n  if (context === null) {\r\n    throw new Error('You need to wrap your form with a GoogleFormProvider')\r\n  }\r\n\r\n  const field = context.getField(id)\r\n\r\n  if (field.type !== type) {\r\n    throw new Error(`Field with id ${field.id} is not of type ${type}`)\r\n  }\r\n\r\n  return field\r\n}\r\n","import * as React from 'react'\r\nimport { UseGoogleFormReturn } from '../types'\r\n\r\nconst GoogleFormContext = React.createContext<UseGoogleFormReturn | null>(null)\r\nexport const useGoogleFormContext = () => React.useContext(GoogleFormContext)\r\n\r\nexport const GoogleFormProvider = ({\r\n  children,\r\n  ...other\r\n}: {\r\n  children: React.ReactNode\r\n}) => {\r\n  return (\r\n    <GoogleFormContext.Provider value={other as UseGoogleFormReturn}>\r\n      {children}\r\n    </GoogleFormContext.Provider>\r\n  )\r\n}\r\n","import { useState, useEffect } from 'react'\r\nimport slugify from 'slugify'\r\n\r\nimport {\r\n  UseCustomOptionReturn,\r\n  Option,\r\n  BaseField,\r\n  UseCustomOptionField,\r\n  CustomOptionField\r\n} from '../../types'\r\nimport getFieldFromContext from './getFieldFromContext'\r\nimport { useGoogleFormContext } from '../useGoogleFormContext'\r\nimport { RegisterOptions } from 'react-hook-form'\r\n\r\nexport const OTHER_OPTION = '__other_option__'\r\nexport const OTHER_OPTION_RESPONSE = 'other_option_response'\r\n\r\nexport const buildCustomFieldId = (id: string) => {\r\n  return `${id}-${OTHER_OPTION_RESPONSE}`\r\n}\r\n\r\nexport default (\r\n  id: string,\r\n  type: 'CHECKBOX' | 'RADIO'\r\n): UseCustomOptionField => {\r\n  const context = useGoogleFormContext()\r\n  const field = getFieldFromContext(context, id, type) as CustomOptionField\r\n\r\n  const [isCustomOptionSelected, setIsCustomOptionSelected] =\r\n    useState<boolean>(false)\r\n  const [customInputRequired, setCustomInputRequired] = useState<boolean>(false)\r\n\r\n  const register = (options?: RegisterOptions) =>\r\n    context!.register(id, { required: field.required, ...options })\r\n\r\n  const currentValue = context!.watch(id)\r\n\r\n  useEffect(() => {\r\n    if (field.type === 'RADIO') {\r\n      const isCustomOptionSelected =\r\n        currentValue && currentValue === OTHER_OPTION\r\n      setCustomInputRequired(field.required && isCustomOptionSelected)\r\n      setIsCustomOptionSelected(isCustomOptionSelected)\r\n    } else {\r\n      const isCustomOptionSelected =\r\n        currentValue &&\r\n        currentValue.length === 1 &&\r\n        currentValue.includes(OTHER_OPTION)\r\n      setCustomInputRequired(field.required && isCustomOptionSelected)\r\n      setIsCustomOptionSelected(isCustomOptionSelected)\r\n    }\r\n  }, [currentValue, customInputRequired])\r\n\r\n  const nonCustomOptions = field.options.filter(\r\n    (o) => !o.custom\r\n  ) as Array<Option>\r\n\r\n  const buildId = (value: string) => {\r\n    return `${id}-${slugify(value)}`\r\n  }\r\n\r\n  const buildOptionRegister = (o: Option) => {\r\n    const id = buildId(o.label)\r\n    const registerOption = (options: RegisterOptions) => ({\r\n      ...register({ ...options }),\r\n      value: o.label\r\n    })\r\n\r\n    return {\r\n      ...o,\r\n      id,\r\n      registerOption\r\n    }\r\n  }\r\n\r\n  const result = {\r\n    options: nonCustomOptions.map(buildOptionRegister)\r\n  } as UseCustomOptionReturn\r\n\r\n  const customOption = field.options.find((o) => o.custom) as Option\r\n  if (customOption) {\r\n    const id = buildId(OTHER_OPTION)\r\n    const registerOption = (options = {}) => ({\r\n      ...register({ ...options }),\r\n      value: OTHER_OPTION\r\n    })\r\n\r\n    const customOptionId = buildCustomFieldId(id)\r\n\r\n    const registerCustomInput = (options = {}) => {\r\n      return context!.register(customOptionId, {\r\n        required: customInputRequired,\r\n        ...options\r\n      })\r\n    }\r\n\r\n    const error = context!.formState.errors[customOptionId]\r\n\r\n    result.customOption = {\r\n      ...customOption,\r\n      id,\r\n      registerOption,\r\n      registerCustomInput,\r\n      error\r\n    }\r\n  }\r\n\r\n  const error = context!.formState.errors[field.id]\r\n\r\n  return {\r\n    ...(field as BaseField),\r\n    ...result,\r\n    error,\r\n    isCustomOptionSelected\r\n  }\r\n}\r\n","import fetch from 'isomorphic-unfetch'\nimport { GoogleForm } from '../types'\nimport {\n  OTHER_OPTION,\n  OTHER_OPTION_RESPONSE\n} from '../hooks/utils/useCustomOptionField'\n\n// export const GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d'\nexport const GOOGLE_FORMS_URL =\n  'https://survey.pizzahut.vn/api/google-form-proxy'\nexport const GOOGLE_FORMS_URL_DEV =\n  'http://localhost:4000/api/google-form-proxy'\n\nexport const formatQuestionName = (id: string) => {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return `entry.${id.replace(\n      `-${OTHER_OPTION}-${OTHER_OPTION_RESPONSE}`,\n      ''\n    )}.${OTHER_OPTION_RESPONSE}`\n  }\n\n  return `entry.${id}`\n}\n\nexport const submitToGoogleForms = async (\n  form: GoogleForm,\n  formData: object,\n  isDev: boolean\n): Promise<boolean> => {\n  const urlParams = new URLSearchParams()\n  Object.keys(formData).forEach((key) => {\n    if (formData[key]) {\n      if (formData[key].constructor === Array) {\n        formData[key].forEach((answer: string) => {\n          urlParams.append(formatQuestionName(key), answer)\n        })\n      } else {\n        urlParams.append(formatQuestionName(key), formData[key])\n      }\n    }\n  })\n  const finalURL: string = isDev ? GOOGLE_FORMS_URL_DEV : GOOGLE_FORMS_URL\n  const fetchedResult = await fetch(\n    `${finalURL}/${\n      form.action\n    }/formResponse?submit=Submit&${urlParams.toString()}`,\n    {\n      method: 'GET',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }\n  )\n\n  const wasSuccessful =\n    fetchedResult.ok &&\n    fetchedResult.status < 300 &&\n    fetchedResult.status >= 200\n\n  return wasSuccessful\n}\n","import { useForm } from 'react-hook-form'\nimport { GoogleForm, UseGoogleFormReturn } from '../types'\nimport { submitToGoogleForms } from '../scripts/submitToGoogleForms'\n\nconst resolveField = (id: string, form: GoogleForm) => {\n  const fieldIndex = form.fieldsOrder[id]\n\n  if (fieldIndex === undefined) {\n    throw new Error(`Field with id ${id} wasn't found in your form`)\n  }\n\n  return form.fields[fieldIndex]\n}\n\nexport const useGoogleForm = ({ form }: { form: GoogleForm }) => {\n  const methods = useForm() as UseGoogleFormReturn\n\n  methods.getField = (id: string) => resolveField(id, form)\n\n  methods.submitToGoogleForms = (formData, isDev) =>\n    submitToGoogleForms(form, formData, isDev)\n\n  return methods\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\r\nimport { UseCustomOptionField } from '../types'\r\n\r\nexport const useRadioInput = (id: string): UseCustomOptionField => {\r\n  return useCustomOptionField(id, 'RADIO')\r\n}\r\n","import useCustomOptionField from './utils/useCustomOptionField'\r\nimport { UseCustomOptionField } from '../types'\r\n\r\nexport const useCheckboxInput = (id: string): UseCustomOptionField => {\r\n  return useCustomOptionField(id, 'CHECKBOX')\r\n}\r\n","import { RegisterOptions } from 'react-hook-form'\r\n\r\nimport { UseTextFieldReturn, TextField } from '../../types'\r\nimport { useGoogleFormContext } from '../useGoogleFormContext'\r\nimport getFieldFromContext from './getFieldFromContext'\r\n\r\nexport default (\r\n  id: string,\r\n  fieldType: 'LONG_ANSWER' | 'SHORT_ANSWER'\r\n): UseTextFieldReturn => {\r\n  const context = useGoogleFormContext()\r\n\r\n  const field = getFieldFromContext(context, id, fieldType) as TextField\r\n\r\n  const error = context!.formState.errors[field.id]\r\n\r\n  const register = (options?: RegisterOptions) =>\r\n    context!.register(id, { required: field.required, ...options })\r\n\r\n  return { ...field, register, error }\r\n}\r\n","import useTextInput from './utils/useTextInput'\r\n\r\nexport const useShortAnswerInput = (id: string) => {\r\n  return useTextInput(id, 'SHORT_ANSWER')\r\n}\r\n","import useTextInput from './utils/useTextInput'\r\n\r\nexport const useLongAnswerInput = (id: string) => {\r\n  return useTextInput(id, 'LONG_ANSWER')\r\n}\r\n","import { useEffect, useState } from 'react'\r\nimport { RegisterOptions } from 'react-hook-form'\r\nimport slugify from 'slugify'\r\n\r\nimport { useGoogleFormContext } from '../useGoogleFormContext'\r\nimport getFieldFromContext from './getFieldFromContext'\r\nimport {\r\n  UseGridFieldReturn,\r\n  GridField,\r\n  RenderLineFunction,\r\n  RenderColumnFunction,\r\n  GridErrors\r\n} from '../../types'\r\n\r\nexport default (\r\n  id: string,\r\n  type: 'RADIO_GRID' | 'CHECKBOX_GRID'\r\n): UseGridFieldReturn => {\r\n  const context = useGoogleFormContext()\r\n  const [errors, setErrors] = useState<GridErrors | undefined>(undefined)\r\n\r\n  const field = getFieldFromContext(context, id, type) as GridField\r\n\r\n  const buildId = (lineId: string, value: string) => {\r\n    return `${id}-${lineId}-${slugify(value)}`\r\n  }\r\n\r\n  useEffect(() => {\r\n    const newErrors: GridErrors = field.lines.reduce((acc: GridErrors, l) => {\r\n      const fieldError = context!.formState.errors[l.id]\r\n      if (fieldError) {\r\n        acc[l.id] = fieldError\r\n      }\r\n      return acc\r\n    }, {})\r\n\r\n    if (Object.keys(newErrors).length > 0) {\r\n      setErrors(newErrors)\r\n    } else {\r\n      setErrors(undefined)\r\n    }\r\n  }, [context!.formState.errors])\r\n\r\n  const renderGrid = (render: RenderLineFunction): JSX.Element[] => {\r\n    return field.lines.map((l) => {\r\n      const registerLine = (options?: RegisterOptions) =>\r\n        context!.register(l.id, { required: field.required, ...options })\r\n\r\n      const renderColumns = (render: RenderColumnFunction): JSX.Element[] => {\r\n        return field.columns.map((c) => {\r\n          const id = buildId(l.id, c.label)\r\n          const registerColumn = (options?: RegisterOptions) => ({\r\n            ...registerLine(options),\r\n            value: c.label\r\n          })\r\n\r\n          return render({ ...c, registerColumn, id })\r\n        })\r\n      }\r\n\r\n      return render({ ...l, renderColumns })\r\n    })\r\n  }\r\n\r\n  return { ...field, renderGrid, errors }\r\n}\r\n","import useGridInput from './utils/useGridInput'\r\n\r\nexport const useCheckboxGridInput = (id: string) => {\r\n  return useGridInput(id, 'CHECKBOX_GRID')\r\n}\r\n","import useGridInput from './utils/useGridInput'\r\n\r\nexport const useRadioGridInput = (id: string) => {\r\n  return useGridInput(id, 'RADIO_GRID')\r\n}\r\n","import slugify from 'slugify'\r\n\r\nimport { useGoogleFormContext } from './useGoogleFormContext'\r\nimport getFieldFromContext from './utils/getFieldFromContext'\r\nimport { UseDropdownReturn, DropdownField } from '../types'\r\nimport { RegisterOptions } from 'react-hook-form'\r\n\r\nexport const useDropdownInput = (id: string): UseDropdownReturn => {\r\n  const context = useGoogleFormContext()\r\n\r\n  const field = getFieldFromContext(context, id, 'DROPDOWN') as DropdownField\r\n\r\n  const register = (options?: RegisterOptions) =>\r\n    context!.register(id, { required: field.required, ...options })\r\n\r\n  const error = context!.formState.errors[field.id]\r\n\r\n  const buildId = (value: string) => {\r\n    return `${field.id}-${slugify(value)}`\r\n  }\r\n\r\n  const options = field.options.map((o) => {\r\n    const id = buildId(o.label)\r\n    return {\r\n      ...o,\r\n      id\r\n    }\r\n  })\r\n\r\n  return { ...field, options, register, error }\r\n}\r\n","import slugify from 'slugify'\r\nimport { RegisterOptions } from 'react-hook-form'\r\n\r\nimport { useGoogleFormContext } from './useGoogleFormContext'\r\nimport getFieldFromContext from './utils/getFieldFromContext'\r\nimport { UseLinearInputReturn, LinearField } from '../types'\r\n\r\nexport const useLinearInput = (id: string): UseLinearInputReturn => {\r\n  const context = useGoogleFormContext()\r\n\r\n  const field = getFieldFromContext(context, id, 'LINEAR') as LinearField\r\n\r\n  const register = (options?: RegisterOptions) =>\r\n    context!.register(id, { required: field.required, ...options })\r\n\r\n  const buildId = (value: string) => {\r\n    return `${field.id}-${slugify(value)}`\r\n  }\r\n\r\n  const error = context!.formState.errors[field.id]\r\n\r\n  const options = field.options.map((o) => {\r\n    const id = buildId(o.label)\r\n    const registerOption = (options?: RegisterOptions) => ({\r\n      ...register(options),\r\n      value: o.label\r\n    })\r\n\r\n    return {\r\n      ...o,\r\n      id,\r\n      registerOption\r\n    }\r\n  })\r\n\r\n  return { ...field, options, error }\r\n}\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import * as cheerio from 'cheerio'\nimport fetch from 'isomorphic-unfetch'\n\nimport {\n  Column,\n  CustomizableOption,\n  Field,\n  FieldsOrder,\n  GoogleForm,\n  Line,\n  Option\n} from '../types/form'\n\ntype FormData = {\n  formData: object\n  fbzx: string\n}\n\nconst toBool = (n: number): boolean => n === 1\n\nconst toString = (n: number): string => `${n}`\n\n// const assertValidUrl = (formUrl: string): void => {\n//   const googleFormsHosts = [\n//     'docs.google.com',\n//     'forms.gle',\n//     'localhost:4000',\n//     'survey.pizzahut.vn'\n//   ]\n//   const url = new URL(formUrl)\n//\n//   if (!googleFormsHosts.includes(url.host)) {\n//     throw new Error(\n//       `Invalid google forms host. ${\n//         url.host\n//       } is expected to be ${googleFormsHosts\n//         .join(', ')\n//         .replace(/, ([^,]*)$/, ' or $1')}.`\n//     )\n//   }\n//\n//   if (url.host === googleFormsHosts[0] && !url.pathname.endsWith('/viewform')) {\n//     throw new Error(`Please use the form's public URL.`)\n//   }\n// }\n\nconst getFormHtml = async (formUrl: string) => {\n  const response = await fetch(formUrl)\n  return await response.text()\n}\n\nconst extractFormData = (html: string): FormData => {\n  const $ = cheerio.load(html)\n  const fbzx = $('[name=\"fbzx\"]').attr('value')\n\n  if (!fbzx) {\n    throw new Error(`Invalid form. Couldn't find fbzx field.`)\n  }\n\n  const scriptStringIdentifier = 'var FB_PUBLIC_LOAD_DATA_ ='\n  let scriptHtml = $('script')\n    .filter((_, el) => {\n      return $(el).html()!.includes(scriptStringIdentifier)\n    })\n    .first()\n    .html()\n\n  if (!scriptHtml) {\n    throw new Error(`Invalid form. Couldn't find script tag.`)\n  }\n\n  scriptHtml = scriptHtml.slice(0, -1)\n  scriptHtml = scriptHtml.replace(scriptStringIdentifier, '')\n\n  const formDataRaw = JSON.parse(scriptHtml)\n\n  return { formData: formDataRaw, fbzx }\n}\n\nconst parseGridMultiSelect = (rawField: Array<object>): 1 | 0 => {\n  const firstLine = rawField[4][0]\n  const canSelectMultiple = firstLine[11][0]\n\n  return canSelectMultiple\n}\n\nconst parseFieldType = (rawField: Array<object>, fieldId: number) => {\n  const fieldTypes = [\n    'SHORT_ANSWER',\n    'LONG_ANSWER',\n    'RADIO',\n    'DROPDOWN',\n    'CHECKBOX',\n    'LINEAR'\n  ] as const\n\n  if (fieldId === 7) {\n    if (parseGridMultiSelect(rawField) === 1) {\n      return 'CHECKBOX_GRID'\n    } else {\n      return 'RADIO_GRID'\n    }\n  }\n  if (fieldId === 9) {\n    return 'DATE'\n  }\n\n  return fieldTypes[fieldId]\n}\n\nconst parseOptions = (options: Array<object>): Array<Option> => {\n  return options.map((rawOption) => ({ label: rawOption[0] }))\n}\n\nconst parseCustomizableOptions = (\n  options: Array<object>\n): Array<CustomizableOption> => {\n  return options.map((rawOption) => ({\n    label: rawOption[0],\n    custom: rawOption[4] === 1\n  }))\n}\n\nconst flattenArray = (array: Array<Array<string>>): Array<Option | Column> => {\n  return array.map((item) => ({ label: item[0] }))\n}\n\nconst parseLines = (lines: Array<any>): Array<Line> => {\n  return lines.map((rawLine) => {\n    const line = {} as Line\n    line.id = toString(rawLine[0])\n    line.label = rawLine[3][0]\n    return line\n  })\n}\n\nconst parseField = (rawField: Array<any>): Field => {\n  const field = {} as Field\n\n  field.label = rawField[1]\n  field.description = rawField[2]\n\n  const fieldId = rawField[3]\n  field.type = parseFieldType(rawField, fieldId)\n\n  switch (field.type) {\n    case 'SHORT_ANSWER':\n    case 'LONG_ANSWER': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX':\n    case 'RADIO': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseCustomizableOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'DROPDOWN': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'LINEAR': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      const [labelFirst, labelLast] = fieldInfo[3]\n      field.legend = { labelFirst, labelLast }\n      field.options = flattenArray(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX_GRID':\n    case 'RADIO_GRID': {\n      field.id = toString(rawField[0])\n      field.columns = flattenArray(rawField[4][0][1])\n      field.lines = parseLines(rawField[4])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n    case 'DATE': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n  }\n\n  return field\n}\n\nconst parseFields = (\n  rawFields: Array<any>\n): { fields: Array<Field>; fieldsOrder: FieldsOrder } => {\n  const fieldsOrder = {}\n\n  const fields = rawFields.map((rawField: Array<any>, i: number) => {\n    const field = parseField(rawField)\n    fieldsOrder[`${field.id}`] = i\n    return field\n  })\n\n  return { fields, fieldsOrder }\n}\n\nconst parseFormData = ({ formData, fbzx }: FormData): GoogleForm => {\n  const googleForm = {} as GoogleForm\n\n  googleForm.fvv = 1\n  googleForm.pageHistory = 0\n  googleForm.fbzx = fbzx\n  googleForm.action = formData[14]\n  googleForm.title = formData[1][8]\n  googleForm.description = formData[1][0]\n\n  const { fields, fieldsOrder } = parseFields(formData[1][1])\n  googleForm.fields = fields\n  googleForm.fieldsOrder = fieldsOrder\n\n  return googleForm\n}\n\nexport const googleFormsToJson = async (formUrl: string) => {\n  // assertValidUrl(formUrl)\n\n  let html\n  try {\n    html = await getFormHtml(formUrl)\n  } catch (err) {\n    throw new Error(`Failed to fetch form. ${err}`)\n  }\n\n  const formData = extractFormData(html)\n  return parseFormData(formData)\n}\n"],"names":["context","id","type","Error","field","getField","GoogleFormContext","React","useGoogleFormContext","GoogleFormProvider","children","other","Provider","value","OTHER_OPTION","OTHER_OPTION_RESPONSE","buildCustomFieldId","getFieldFromContext","useState","isCustomOptionSelected","setIsCustomOptionSelected","customInputRequired","setCustomInputRequired","register","options","required","currentValue","watch","useEffect","length","includes","nonCustomOptions","filter","o","custom","buildId","slugify","buildOptionRegister","label","registerOption","result","map","customOption","find","customOptionId","registerCustomInput","error","formState","errors","GOOGLE_FORMS_URL","GOOGLE_FORMS_URL_DEV","formatQuestionName","replace","submitToGoogleForms","form","formData","isDev","urlParams","URLSearchParams","Object","keys","forEach","key","constructor","Array","answer","append","finalURL","fetch","action","toString","method","mode","headers","fetchedResult","wasSuccessful","ok","status","resolveField","fieldIndex","fieldsOrder","undefined","fields","useGoogleForm","methods","useForm","useRadioInput","useCustomOptionField","useCheckboxInput","fieldType","useShortAnswerInput","useTextInput","useLongAnswerInput","setErrors","lineId","newErrors","lines","reduce","acc","l","fieldError","renderGrid","render","registerLine","renderColumns","columns","c","registerColumn","useCheckboxGridInput","useGridInput","useRadioGridInput","useDropdownInput","useLinearInput","toBool","n","getFormHtml","formUrl","response","text","extractFormData","html","$","cheerio","fbzx","attr","scriptStringIdentifier","scriptHtml","_","el","first","slice","formDataRaw","JSON","parse","parseGridMultiSelect","rawField","firstLine","canSelectMultiple","parseFieldType","fieldId","fieldTypes","parseOptions","rawOption","parseCustomizableOptions","flattenArray","array","item","parseLines","rawLine","line","parseField","description","fieldInfo","labelFirst","labelLast","legend","parseFields","rawFields","i","parseFormData","googleForm","fvv","pageHistory","title","googleFormsToJson","err"],"mappings":"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"}